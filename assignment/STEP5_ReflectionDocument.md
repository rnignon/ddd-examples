# STEP 5. 일관성 검증 및 회고

---

## 1. 설계 개요

본 문서는 대출 심사 및 승인 시스템 설계 과정에서 겪은 주요 고민과 결정 사항을 기록합니다.

**핵심 질문:** "왜 이렇게 나누었는가?"

---

## 2. 주요 설계 결정 사항

### 2.1 신청-심사-승인 Context 분리 여부

#### 문제 상황
처음에는 대출 신청, 심사, 승인을 각각 별도 Context로 나눌지 고민했습니다.

#### 해결 과정
- 기획서에서 "대출 심사 및 승인 시스템"으로 하나의 시스템으로 정의
- 여신심사팀이 신청부터 승인까지 전체를 담당
- 용어(신청서, 심사 의견, 승인 한도)가 일관되게 사용됨

#### 결론
**하나의 Context로 통합** - 대출 심사 Context (Loan Review Context)
- 동일 조직, 동일 생명주기, 일관된 언어 → 분리 불필요
- Aggregate 경계로 트랜잭션 일관성 해결 가능

**반면 대출 실행과 상환 관리는 분리**
- 담당 조직 다름 (실행팀, 여신관리팀)
- 생명주기 독립적
- 각자의 책임과 관심사 명확

---

### 2.2 외부 신용 조회 처리

#### 문제 상황
NICE, KCB 등 외부 신용평가 연동이 중요하고 복잡한데, 별도 Context로 분리할지 고민했습니다.

#### 해결 과정
- 신용 조회는 "심사"의 일부 단계
- 심사와 독립적으로 존재할 의미 없음
- 별도 Context 분리 시 네트워크 호출과 트랜잭션 관리만 복잡해짐

#### 결론
**대출 심사 Context 내부의 도메인 서비스로 처리**
- `CreditInquiryService`를 심사 Context 내부에 배치
- 중요하다고 반드시 분리하는 것은 아님
- 복잡하면 모듈로 분리하면 충분

---

### 2.3 Context 간 의존성 방향

#### 문제 상황
"사용자가 상품을 선택하고 신청한다"는 흐름 때문에  
사용자 → 대출 상품 → 대출 심사 순서로 의존성을 설정하려 했습니다.

#### 해결 과정
- 시간의 흐름 ≠ 의존성 방향
- "누가 누구를 필요로 하는가"로 판단해야 함
- 대출 심사를 하려면: 사용자 정보 + 상품 정보 모두 필요

#### 결론
**대출 심사 Context가 사용자·상품 Context 모두에 의존**
```
[사용자 Context] ←────┐(Customer)
[대출 상품 Context] ←─│
            [대출 심사 Context]
            (Supplier들의 정보 사용)
```

---

### 2.4 알림 Context 설계

#### 문제 상황
알림을 이벤트 방식으로 할지, API 호출 방식으로 할지 고민했습니다.

#### 해결 과정
**이벤트 방식 (Customer/Supplier):**
- 각 도메인이 이벤트 발행 → 알림이 구독
- 문제: 이벤트 유실 가능성, 중요한 알림 발송 보장 어려움

**API 호출 방식 (OHS/PL):**
- 알림이 공개 API 제공 → 각 도메인이 직접 호출
- 장점: 즉시 성공/실패 확인, 발송 보장 용이

#### 결론
**OHS/PL 관계로 설계**
- 약정, 전자서명 등 **반드시 발송되어야 하는** 중요 알림이 많음
- 동기 호출로 즉시 성공/실패 확인 가능
- 트레이드오프: 결합도 증가하지만, 발송 보장이 더 중요

---

### 2.5 약정 관리 책임 배치

#### 문제 상황
전자 서명, 약정 체결을 어느 Context에서 관리해야 하는지 불명확했습니다.

#### 해결 과정
**옵션 검토:**
1. 대출 실행 Context에 포함
2. 별도 약정 Context 분리
3. 대출 심사 Context의 후속 작업

#### 결론
**대출 실행 Context에 포함**
- 약정 없이 실행 불가능, 실행 없는 약정도 의미 없음 (강한 결합)
- 대출 실행 = 약정 체결 + 자금 지급 (하나의 프로세스)
- 대출 실행팀이 약정부터 지급까지 전체 담당 (Conway's Law)

---

### 2.6 애그리거트 경계와 구성 요소 관리

#### 문제 상황
애그리거트의 구성요소 중 일부는 생성 시점이 아닌 단계적으로 추가되는 경우가 있었습니다.

애그리거트 루트와 구성요소의 생성 시점이 달라 서로 다른 라이프 사이클을 갖는 것처럼 보여, 애그리거트를 분리해야 하는지 고민했습니다.

#### 해결 과정
- 일관성 경계 기준 확인 : 애그리거트의 판단 기준은 생성 시점이 아닌 일관성 경계임을 확인
- 구성 요소 의미 확인 : 값 객체와 내부 엔티티가 동일한 일관성 경계 안에서 의미를 가지며, 애그리거트 삭제 시 함께 삭제되는 점을 고려

따라서 단계별로 구성 요소가 추가되더라도, 동일한 일관성 경계 내에 있다면 하나의 애그리거트로 유지 가능

#### 결론
동일한 일관성 경계를 가진 구성 요소들은 단계적으로 생성되더라도 하나의 애그리거트로 유지

각 단계별 상태를 정의하여 가능한 작업을 제한하는 방향으로 설계함으로써 애그리거트의 무결성을 보장

---

## 3. 설계 원칙 정리

### Context 분리 기준

**분리해야 할 때:**
- 담당 조직이 다름
- 생명주기가 독립적
- 관심사가 명확히 구분됨

**분리하지 말아야 할 때:**
- 동일한 조직이 관리
- 생명주기가 강하게 결합
- 용어가 일관되게 사용됨

### Context 관계 판단

**Customer/Supplier:**
- "A가 B의 정보를 필요로 한다" → A는 Customer, B는 Supplier
- 시간 순서가 아닌 의존성 방향으로 판단

**OHS/PL:**
- 한 Context가 표준화된 공개 API 제공
- 다른 Context들이 직접 API 호출

### 도메인 서비스 vs 별도 Context

| 판단 기준 | 도메인 서비스 | 별도 Context |
|-----------|--------------|-------------|
| 생명주기 | 상위 Context의 일부 | 독립적 |
| 조직 경계 | 동일 팀 | 다른 팀 |
| 재사용성 | 특정 Context 전용 | 여러 Context 사용 |

---